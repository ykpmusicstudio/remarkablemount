//#use fuser
use clap::{Parser, Subcommand, ValueEnum};
/*
use rk_filesystem::FsBuilder;
use ssh_helper::SshHelper;*/

use log::{debug, error, info, trace, warn, LevelFilter};
use std::path::Path;

use crate::sftp_rkfs;

/*
mod fs_handler;
mod remarkablefs;
mod rk_filesystem;
mod ssh_helper;*/

/// Remarkable tablet fuse driver
#[derive(Parser, Debug)]
#[command(version,about,long_about=None)]
struct Args {
    /// remarkable tablet IP address (defaults to 10.x.x.x)
    #[arg(short, long, default_value = "10.11.99.1")]
    address: String,
    /// port number for ssh to remarkable tablet
    #[arg(short, long, default_value = "22")]
    port: Option<u16>,
    /// username
    #[arg(short, long, default_value = "root")]
    username: Option<String>,
    /// hostname and user login as <[USER@]HOST[:PORT]>
    #[arg(long, default_value = "root@10.11.99.1:22")]
    host: String,

    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand, Debug)]
enum Commands {
    /// List identities
    Identities {},
    /// Mount remarkable tablet documents
    Mount {
        /// Mount point for documents
        #[arg(short, long)]
        mountpoint: String,
    },
    /// Unmount remarkable tablet documents if previously mounted
    Umount {},
}

// TODO remove password !!
const RK_PWD: &str = "i7GHdeZBqn";
// TODO handle Rk root path
const RK_ROOTPATH: &str = "/home/root/.local/share/remarkable/xochitl/";

fn mount_rkfs(mountpoint: &str, addr: &str, user: &str) {
    info!("Mounting to {mountpoint} from {user}@{addr}");
    let mut fsb = FsBuilder::new(SshHelper::new());
    let options = fsb.get_options();
    fsb.connect_device(addr, user, RK_PWD)
        .expect("Err when authenticating with remarkable tablet.");
    fsb.build_fs(Path::new(RK_ROOTPATH))
        .expect("Err when constucting fsBuilder");
    fsb.update_tree().expect("Error when building fs tree.");
    fsb.log_tree();
    //panic!("Will stop here for now!");
    let result = fuser::mount2(fsb, mountpoint, &options);
    match result {
        Ok(_) => {
            assert!(false, "Succes!");
        }
        Err(e) => assert!(false, "Failed to mount: {:?}", e),
    }
}

fn main() {
    simple_logger::init_with_level(log::Level::Trace).unwrap();

    let args = Args::parse();
    // match the requested command
    match &args.command {
        Commands::Identities {} => {
            println!("Available identities: ");
        }
        Commands::Mount { mountpoint } => {
            if let Some(usr) = args.username {
                let mut adr = args.address;
                adr.push(':');
                adr.push_str(&args.port.unwrap_or(22).to_string());
                mount_rkfs(mountpoint, &adr, &usr);
            }
        }
        Commands::Umount {} => {
            println!("Umounting");
        }
    }
}
